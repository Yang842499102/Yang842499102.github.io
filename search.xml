<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>vue通过.sync实现父子组件传值双向绑定</title>
      <link href="/2021/05/13/vue-tong-guo-sync-shi-xian-fu-zi-zu-jian-chuan-zhi-shuang-xiang-bang-ding/"/>
      <url>/2021/05/13/vue-tong-guo-sync-shi-xian-fu-zi-zu-jian-chuan-zhi-shuang-xiang-bang-ding/</url>
      
        <content type="html"><![CDATA[<h2 id="1-普通父子组件传值"><a href="#1-普通父子组件传值" class="headerlink" title="1. 普通父子组件传值"></a>1. 普通父子组件传值</h2><p>​    正常vue父子组件传值中</p><ul><li>父组件向子组件传值：</li></ul><p>​    父组件通过在子组件标签上添加想要传送的属性即可，如下图：</p><p><img src="https://yzaio.gitee.io/medias/images/18.jpg" alt="父向子传值"></p><p><font color="pink"><strong>其中在属性前面加上：是使用了v-bind动态绑定即可以传送变量，如果不加上：则会把fatherStr作为一个字符串传送过去子组件</strong></font></p><hr><ul><li><p>子组件接收传值：</p><p><img src="https://yzaio.gitee.io/medias/images/19.jpg" alt="子接收传值"></p><p><font color="pink"><strong>在子组件中的props中进行接收父亲组件的传值</strong></font></p></li></ul><hr><ul><li><p>子向父亲传值：</p><p><img src="https://yzaio.gitee.io/medias/images/20.jpg" alt="子向父传值"></p><p><img src="https://yzaio.gitee.io/medias/images/21.jpg" alt="子向父传值"></p><p><font color="pink">子组件通过$emit发射一个函数，并可携带值，父亲组件通过绑定事件接收参数。</font></p></li></ul><h2 id="2-通过-sync实现父子组件数据双向绑定"><a href="#2-通过-sync实现父子组件数据双向绑定" class="headerlink" title="2. 通过.sync实现父子组件数据双向绑定"></a>2. 通过.sync实现父子组件数据双向绑定</h2><ul><li><p>父亲组件向子组件传值：</p><p><img src="https://yzaio.gitee.io/medias/images/22.jpg" alt="通过.sync进行传值绑定"></p><hr></li></ul><ul><li><p>子组件接收值：</p><p><img src="https://yzaio.gitee.io/medias/images/23.jpg" alt="子组件接收值并实时更新父组件绑定值"></p><p><font color="pink">子组件在接收到值后这次通过$emit发送事件加上update标识，通知父组件中与当前子组件的childStr参数绑定的变量实时更新，这样就做到了父子组件数据的双向绑定</font></p></li><li><p>最终效果如下：</p><p><img src="https://yzaio.gitee.io/medias/images/24.mkv" alt=""></p><video id="video" controls="" preload="none" poster="https://yzaio.gitee.io/medias/images/27.png">     <source id="mp4" src="https://yzaio.gitee.io/medias/images/24.mkv" type="video/mp4"></video></li></ul><h2 id="3-解决直接修改props控制台报错"><a href="#3-解决直接修改props控制台报错" class="headerlink" title="3. 解决直接修改props控制台报错"></a>3. 解决直接修改props控制台报错</h2><p>​    第二步能实现了父子组件通信数据双向绑定，但是会在控制台报以下错误</p><p><img src="https://yzaio.gitee.io/medias/images/25.jpg" alt=""></p><p>​    这个错误的导致是因为我们直接修改了props造成的警告，虽然不影响功能，但是还是需要修改一下，遵守规范</p><p>​    <font color="lightGreen">在子组件data中定义多一个变量childStr_copy来接收props的参数，可以把它当成中转值，这样我们就不会直接修改到props中的值了，修改后代码如下：</font></p><p><img src="https://yzaio.gitee.io/medias/images/26.jpg" alt=""></p><p>这样控制台的警告就消失了</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue中实现骨架屏</title>
      <link href="/2021/05/11/vue-zhong-shi-xian-gu-jia-ping/"/>
      <url>/2021/05/11/vue-zhong-shi-xian-gu-jia-ping/</url>
      
        <content type="html"><![CDATA[<h2 id="1-什么是骨架屏"><a href="#1-什么是骨架屏" class="headerlink" title="1. 什么是骨架屏"></a>1. 什么是骨架屏</h2><p>​    骨架屏一般用于页面在请求远程数据尚未完成时，页面用灰色块预显示本来的页面结构，给用户更好的体验</p><h2 id="2-为什么需要骨架屏"><a href="#2-为什么需要骨架屏" class="headerlink" title="2.  为什么需要骨架屏"></a>2.  为什么需要骨架屏</h2><p>​    去饭店吃饭，需要排队了</p><p>​    1. 白屏：</p><p>​    饭店就只撂下一句话，我们在营业，吃饭要排队，用户等一会就不想等了</p><p>​    2. loading:</p><p>​    饭店给你取了个号，告诉你是在排队，可能很快就可以了，麻烦再等等吧</p><p>​    3. 骨架屏：</p><p>​    饭店说我是海底捞，我给你取了个号，而且给还了你零食、飞行棋、菜单让你玩着看着先，等也等得舒服一些</p><p><img src="https://yzaio.gitee.io/medias/images/17.png" alt=""></p><h2 id="3-介绍骨架屏"><a href="#3-介绍骨架屏" class="headerlink" title="3. 介绍骨架屏"></a>3. 介绍骨架屏</h2><ul><li><p>白屏时间：</p><p>前、后端分离的架构越来越备受推行，这种架构带来的便利的同时，也带来了一些弊端，比如首屏渲染时间，因为首屏需要请求更多内容，比原来多了更多HTTP的往返时间，这造成了白屏，白屏时间过长，用户体验会大打折扣，如果用户网速差，则白屏时间会更长</p></li><li><p>可以怎么优化：</p><p>白屏时间过长，我们可以做什么？</p><p>1、加速(CDN)或减少HTTP请求损耗</p><p>2、延迟加载</p><p>3、减少请求内容的体积、字体库代替图片等</p><p>4、优化用户等待的体验感</p></li></ul><h2 id="4-骨架屏实现"><a href="#4-骨架屏实现" class="headerlink" title="4.   骨架屏实现"></a>4.   骨架屏实现</h2><p>有4种实现方式</p><ul><li><ol><li><p>骨架图：</p><p>一图解决，直接找设计做一张骨架屏的图片，前端控制显隐</p><p>弊端：图片本身也属于一种加载资源，而且不灵活，每次修改骨架屏还得找设计</p></li></ol></li><li><ol start="2"><li><p>静态html、css</p><p>完全通过 HTML 和 CSS 手写的，手写骨架屏当然可以完全复刻页面的真实样式</p><p>弊端：改动了需求也需要手动维护</p></li></ol></li><li><ol start="3"><li><p>自动遍历</p><p>通过获取页面上的dom得到width、height、top、left等属性去描绘生成对应的骨架区块</p><p>弊端：并非所有场景都适用</p></li></ol></li><li><ol start="4"><li><p>半自动化</p><p>添加预备好的基础数据，渲染当前可视屏幕的骨架区块，相较于html、css维护要简单一些、也可以遍历数据之后存本地</p><p>弊端：手动维护数据</p></li></ol></li></ul><h2 id="5-使用vue-server-renderer-插件在vue种实现骨架屏"><a href="#5-使用vue-server-renderer-插件在vue种实现骨架屏" class="headerlink" title="5.  使用vue-server-renderer 插件在vue种实现骨架屏"></a>5.  使用vue-server-renderer 插件在vue种实现骨架屏</h2><p>   <font color="pink" size="5">使用vue-server-renderer可以将骨架屏代码抽离出来，使用一个 .vue 文件来 coding，之后通过配置嵌入到index.html中，易于维护。</font></p><p>​        <font color="lightGreen">实现步骤：</font></p><ol><li><p>在src下创建一个skeleton文件夹</p><p>在文件夹下创建两个文件，skeleton.entry.js和skeleton.vue</p><p><font color="lightBlue"><code>skeleton.entry.js</code> 是编译 <code>skeleton.vue</code> 的入口文件，类似于我们 Vue 项目中的 <code>main.js</code> 文件；</font></p><p><font color="lightBlue"><code>skeleton.vue</code> 就是我们的骨架屏页面的代码,用于编写我们骨架屏页面的html及css，日后需要改动就在此文件进行改动</font></p><ul><li>skeleton.entry.js文件代码：</li></ul></li></ol><pre><code>import Vue from 'vue'import Skeleton from './skeleton.vue'export default new Vue({  // 根实例简单的渲染应用程序组件  render: h =&gt; h(Skeleton)})</code></pre><ul><li>skeleton.vue文件代码：（骨架屏页面的代码，根据项目需求进行调整，这里只是示例）</li></ul><pre><code>&lt;template&gt;  &lt;div class="skeleton"&gt;    &lt;div class="head"&gt;      &lt;div class="round"&gt;&lt;/div&gt;      &lt;div&gt;        &lt;div class="line"&gt;&lt;/div&gt;        &lt;div class="line"&gt;&lt;/div&gt;      &lt;/div&gt;    &lt;/div&gt;    &lt;div class="skeletoContain"&gt;      &lt;div class="mySkeleton" v-for="item in 5" :key="item"&gt;        孙洲洋的骨架屏      &lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;  .skeleton {    padding: 20vw 5vw 5vw;  }  .head {    display: flex;    align-items: center;  }  .line {    width: 50vw;    height: 3vw;    background-color: #eeeeee;    margin-left: 3vw;  }  .head .line:nth-child(1) {    width: 30vw;    margin-bottom: 5vw;  }  .round {    width: 20vw;    height: 20vw;    border-radius: 50%;    background-color: #eeeeee;  }  .skeletoContain {    display: flex;    flex-wrap: wrap;    justify-content: space-between;    align-items: center;    margin-top: 10vw;  }  .mySkeleton {    width: 25vw;    height: 25vw;    color: lightblue;    background-color: #eee;    display: flex;    justify-content: center;    align-items: center;  }  .skeleton .mySkeleton:nth-child(n+4):nth-child(-n+5) {    border-radius: 50%;    margin-top: 10vw;  }&lt;/style&gt;</code></pre><ol start="2"><li><p>在项目根目录下创建一个webpack.skeleton.conf.js文件，这是一个 webpack 的配置文件，配合使用 <code>vue-server-renderer</code> 将我们的 <code>skeleton.vue</code> 文件内容构建为单个的 json 格式的文件（这是 Vue SSR 渲染的策略）</p><ul><li>文件代码：</li></ul></li></ol><pre><code>// webpack.skeleton.conf.js'use strict'const path = require('path')const nodeExternals = require('webpack-node-externals')const VueSSRServerPlugin = require('vue-server-renderer/server-plugin')const VueLoader = require('vue-loader/lib/plugin')module.exports = {  target: 'node',  devtool: '#source-map',  entry: './src/skeleton/skeleton.entry.js',  output: {    path: path.resolve(__dirname, './dist'),    publicPath: '/dist/',    filename: '[name].js',    libraryTarget: 'commonjs2'  },  module: {    noParse: /es6-promise\.js$/,  // avoid webpack shimming process    rules: [      {        test: /\.vue$/,        loader: 'vue-loader',        options: {          compilerOptions: {            preserveWhitespace: false          }        }      },      {        test: /\.css$/,        use: ['vue-style-loader', 'css-loader']      }    ]  },  performance: {    hints: false  },  externals: nodeExternals({    // do not externalize CSS files in case we need to import it from a dep    allowlist: /\.css$/  }),  plugins: [    // 这是将服务器的整个输出构建为单个 JSON 文件的插件。    // 默认文件名为 `vue-ssr-server-bundle.json`    new VueSSRServerPlugin({      filename: 'skeleton.json'    }),    new VueLoader()  ]}</code></pre><p>   <font size="3" color="lightGreen">此处注意一点：webpack无法打包.vue文件，需要安装相关的loader，即vue-loader，<strong>这个插件是必须的！</strong> 它的职责是将你定义过的其它规则复制并应用到 <code>.vue</code> 文件里相应语言的块。例如，如果你有一条匹配 <code>/\.js$/</code> 的规则，那么它会应用到 <code>.vue</code> 文件里的 <code>&lt;script&gt;</code> 块。 并且在<font color="red">plugins中需要把插件引入</font></font></p><ol start="3"><li><p>需要安装相关依赖</p><p>执行以下命令：</p><ul><li>npm i <a href="mailto:webpack-cli@3.3.10">webpack-cli@3.3.10</a> -D</li><li>npm i webpack-node-externals</li><li>npm i vue-server-renderer</li><li>npm i vue-loader vue-template-compiler -D</li></ul></li><li><p>在package.json中加入命令</p></li></ol><pre><code>"skeleton": "webpack --progress --config build/webpack.skeleton.conf.js"//此命令用于使用webpack-cli 运行这个 webpack.skeleton.conf.js 配置文件</code></pre><ol start="5"><li><p>执行npm run skeleton就会在根目录下创建出一个dist文件夹，其中有一个skeleton.json文件</p></li><li><p>在根目录下创建一个skeleton.js，此文件作用用于将skeleton.json文件的内容插入index.html中</p><p>skeleton.js文件代码：</p></li></ol><pre><code>// skeleton.jsconst fs = require('fs')const { resolve } = require('path')const { createBundleRenderer } = require('vue-server-renderer')function createRenderer(bundle, options) {  return createBundleRenderer(bundle, Object.assign(options, {    // recommended for performance    // runInNewContext: false  }))}const handleError = err =&gt; {  console.error(`error during render : ${req.url}`)  console.error(err.stack)}const bundle = require('./dist/skeleton.json')const templatePath = resolve('./public/index.html')const template = fs.readFileSync(templatePath, 'utf-8')const renderer = createRenderer(bundle, {  template})// console.log(renderer)/** * 说明： * 默认的index.html中包含&lt;%= BASE_URL %&gt;的插值语法 * 我们不在生成骨架屏这一步改变模板中的这个插值 * 因为这个插值会在项目构建时完成 * 但是如果模板中有这个插值语法，而我们在vue-server-renderder中使用这个模板，而不传值的话，是会报错的 * 所以，我们去掉模板中的插值，而使用这个传参的方式，再将这两个插值原模原样返回到模板中 * * 文档： https://cli.vuejs.org/zh/guide/html-and-static-assets.html#%E6%8F%92%E5%80%BC */const context = {  title: '',  // default title  meta: `&lt;meta name="theme-color" content="#4285f4"&gt;    &lt;link rel="icon" href="&lt;%= BASE_URL %&gt;favicon.ico"&gt;    &lt;link rel="stylesheet" href="&lt;%= BASE_URL %&gt;css/reset.css"&gt;`}renderer.renderToString(context, (err, html) =&gt; {  if(err) {    return handleError(err)  }  fs.writeFileSync(resolve(__dirname, './public/index.html'), html, 'utf-8')})</code></pre><ol start="7"><li>在index.html中修改代码增加占位符（index.html 中的 div#app 中要加一个注解插槽，<code>&lt;!--vue-ssr-outlet--&gt;</code> 这个是必须的，Vue SSR 文档中有说这个。这个注解是必须的，请注意！）（<font color="lightGreen">需要注意的是需要把index.html文件中包含的&lt;%= &gt;语法的语句去掉，在上面的skeleton.js中补充进去后面后自动生成到index.html中</font>）</li></ol><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;  &lt;meta charset="utf-8"&gt;  &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;  &lt;meta name="viewport" content="width=device-width,initial-scale=1.0"&gt;  &lt;link rel="icon" href="&lt;%= BASE_URL %&gt;favicon.ico"&gt; //需要去除  &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt; //需要去除&lt;/head&gt;&lt;body&gt;&lt;div id="app"&gt;  &lt;!--vue-ssr-outlet--&gt;&lt;/div&gt;&lt;!-- built files will be auto injected --&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><ol start="8"><li>输入命令node skeleton.js，即会把原先public中的index.html替换掉，运行项目，在network中采用slow 3g模式下可以就可以清楚看到骨架屏效果。</li></ol><p><img src="https://yzaio.gitee.io/medias/images/10.png" alt="本文章代码实现效果"></p><p>后续如果需要修改骨架屏，只需要修改skeleton.vue文件的代码，然后把index.html赋值为第7步中的原始状态，执行npm run skeleton还有node  skeleton.js命令即可</p><p><font color="pink" size="3">到此我们vue中实现骨架屏就告一段落了</font></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逻辑与、逻辑或、空值合并运算符</title>
      <link href="/2021/05/10/luo-ji-yu-luo-ji-huo-kong-zhi-he-bing-yun-suan-fu/"/>
      <url>/2021/05/10/luo-ji-yu-luo-ji-huo-kong-zhi-he-bing-yun-suan-fu/</url>
      
        <content type="html"><![CDATA[<h1 id="逻辑与、逻辑或、空值合并运算符"><a href="#逻辑与、逻辑或、空值合并运算符" class="headerlink" title="逻辑与、逻辑或、空值合并运算符"></a>逻辑与、逻辑或、空值合并运算符</h1><h2 id="1-逻辑与"><a href="#1-逻辑与" class="headerlink" title="1. 逻辑与"></a>1. 逻辑与</h2><ul><li><p>let  a  =  sign &amp;&amp;  ‘执行了’</p><p>如果sign为true的时候  a为执行了，如果sign为false或者nan等会使整个表达式为false的值时，会把sign作为整个表达式的返回值给a，即sign为Nan,则a为Nan，sign为false，a为false</p></li></ul><h2 id="2-逻辑或（一般用来做默认值）"><a href="#2-逻辑或（一般用来做默认值）" class="headerlink" title="2. 逻辑或（一般用来做默认值）"></a>2. 逻辑或（一般用来做默认值）</h2><ul><li><p>let a  =  sign ||  ‘执行了’</p><p>如果sign的Boolean值为true时，会把sign的值作为表达式的值返回给a，即sign为‘111’，则a为‘111’，</p><p>如果sign为false  则a为‘执行了’</p></li></ul><h2 id="3-空值合并运算符"><a href="#3-空值合并运算符" class="headerlink" title="3. 空值合并运算符"></a>3. 空值合并运算符</h2><ul><li><p><strong>空值合并操作符</strong>（<strong><code>??</code></strong>）是一个逻辑操作符，当左侧的操作数为 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/null" target="_blank" rel="noopener"><code>null</code></a> 或者 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined" target="_blank" rel="noopener"><code>undefined</code></a> 时，返回其右侧操作数，否则返回左侧操作数。</p><p>与<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators#logical_or_2" target="_blank" rel="noopener">逻辑或操作符（<code>||</code>）</a>不同，逻辑或操作符会在左侧操作数为<a href="https://developer.mozilla.org/en-US/docs/Glossary/Falsy" target="_blank" rel="noopener">假值</a>时返回右侧操作数。也就是说，如果使用 <code>||</code> 来为某些变量设置默认值，可能会遇到意料之外的行为。比如为假值（例如，<code>''</code> 或 <code>0</code>）时。见下面的例子。</p><p>const foo = null ?? ‘default string’;<br>console.log(foo);<br>// expected output: “default string”</p><p>const baz = 0 ?? 42;<br>console.log(baz);<br>// expected output: 0  (输出为0，如果为逻辑或运算符，则为42)</p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jsx的实质</title>
      <link href="/2021/05/10/jsx-de-shi-zhi/"/>
      <url>/2021/05/10/jsx-de-shi-zhi/</url>
      
        <content type="html"><![CDATA[<h2 id="1-jsx的作用"><a href="#1-jsx的作用" class="headerlink" title="1. jsx的作用"></a>1. jsx的作用</h2><p>​    实际上，jsx 仅仅只是 React.createElement(component, props, …children) 函数的语法糖。 </p><p>​    所有的jsx最终都会被转换成React.createElement的函数调用</p><p>​    JSX是一种JavaScript的语法扩展（eXtension），也在很多地方称之为JavaScript XML，因为看起就是一段XML语法；</p><p>​    它用于描述我们的UI界面，并且其完成可以和JavaScript融合在一起使用；</p><p>​    它不同于Vue中的模块语法，你不需要专门学习模块语法中的一些指令（比如v-for、v-if、v-else、v-bind）；</p><p>​    所以总体而言，jsx就是为了方便我们在js里面以原先html的写法去完成ui界面的书写，后期babel会自动帮我们进行转化</p><h2 id="2-React-createElement"><a href="#2-React-createElement" class="headerlink" title="2. React.createElement"></a>2. React.createElement</h2><p>​    <strong>createElement需要传递三个参数：</strong></p><ul><li><p>参数一：type</p><p>当前ReactElement的类型； </p><p>如果是标签元素，那么就使用字符串表示 “div”； </p><p>如果是组件元素，那么就直接使用组件的名称；</p></li><li><p>参数二：config</p><p>所有jsx中的属性都在config中以对象的属性和值的形式存储</p></li><li><p>参数三：children</p><p>存放在标签中的内容，以children数组的方式进行存储；</p><hr><p><strong>如以下代码的jsx通过createElement函数书写的格式：</strong></p><ul><li>这是jsx的写法<br><img src="https://yzaio.gitee.io/medias/images/7.png" alt="jsx写法"></li></ul></li><li><p>这是使用react.createElement函数的写法</p></li></ul><p><img src="https://yzaio.gitee.io/medias/images/11.png" alt="react.createElement函数的写法"></p><p>  实际上jsx只是语法糖最终打包的时候使用babel会将我们写的jsx代码转化为这种react.createElement的代码给浏览器解析，否则浏览器是无法解析这种jsx代码的</p><h2 id="3-ReactElement对象"><a href="#3-ReactElement对象" class="headerlink" title="3.  ReactElement对象"></a>3.  ReactElement对象</h2><p>  那通过react.createElement函数执行后的结果是什么呢？它就是一个ReactElement对象了。也就是我们说的虚拟dom树</p><p>  <img src="https://yzaio.gitee.io/medias/images/8.png" alt="打印一下jsx即react.CreatElement最终返回结果"></p><p>  我们在这里打印一下react.createElement的最终返回结果，得到以下</p><p>  <img src="https://yzaio.gitee.io/medias/images/9.png" alt="ReactElement对象"></p><p>  可以看到我们最终得到一个对象，它就是ReactElement对象，就是虚拟dom树了，最终再通过react.render方法才将这个虚拟dom转为真实dom</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react中diff算法和列表key值的作用及与vue中diff算法的区别</title>
      <link href="/2021/05/10/react-zhong-diff-suan-fa-he-lie-biao-key-zhi-de-zuo-yong-ji-yu-vue-zhong-diff-suan-fa-de-qu-bie/"/>
      <url>/2021/05/10/react-zhong-diff-suan-fa-he-lie-biao-key-zhi-de-zuo-yong-ji-yu-vue-zhong-diff-suan-fa-de-qu-bie/</url>
      
        <content type="html"><![CDATA[<h1 id="react中diff算法和列表key值的作用及与vue中diff算法的区别"><a href="#react中diff算法和列表key值的作用及与vue中diff算法的区别" class="headerlink" title="react中diff算法和列表key值的作用及与vue中diff算法的区别"></a>react中diff算法和列表key值的作用及与vue中diff算法的区别</h1><h2 id="1-react中diff算法及列表key属性的作用"><a href="#1-react中diff算法及列表key属性的作用" class="headerlink" title="1.react中diff算法及列表key属性的作用"></a>1.react中diff算法及列表key属性的作用</h2><p>React在props或state发生改变时，会调用React的render方法，会创建一颗不同的树。</p><p>React需要基于这两颗不同的树之间的差别来判断如何有效的更新UI： </p><p>如果一棵树参考另外一棵树进行完全比较更新，那么即使是最先进的算法，该算法的复杂程度为 O(n 3 )，其中 n 是树中元素</p><p>的数量； </p><p> <a href="https://grfia.dlsi.ua.es/ml/algorithms/references/editsurvey_bille.pdf；" target="_blank" rel="noopener">https://grfia.dlsi.ua.es/ml/algorithms/references/editsurvey_bille.pdf；</a> </p><p>如果在 React 中使用了该算法，那么展示 1000 个元素所需要执行的计算量将在十亿的量级范围； </p><p>这个开销太过昂贵了，React的更新性能会变得非常低效； </p><p>于是，React对这个diff算法进行了优化，将其优化成了O(n)，如何优化的呢？</p><p>同层节点之间相互比较，不会垮节点比较； </p><p>不同类型的节点，产生不同的树结构；</p><p>开发中，可以通过key来指定哪些节点在不同的渲染下保持稳定；</p><hr><p><font face="逐浪立楷" color="green" size="3">下面通过三步讲下react的diff算法更新虚拟dom和真实dom机制</font></p><h3 id="情况一：对比不同类型的元素"><a href="#情况一：对比不同类型的元素" class="headerlink" title="情况一：对比不同类型的元素"></a><strong>情况一：对比不同类型的元素</strong></h3><ul><li><p>当节点为不同的元素，React会拆卸原有的树，并且建立起新的树：</p><p> 当一个元素从 a标签 变成 img标签，从 Article 变成 Comment，或从 button标签 变成 div都会触发一个完整的重建 </p><p>流程；</p><p>当卸载一棵树时，对应的DOM节点也会被销毁，组件实例将执行 componentWillUnmount() 方法； </p><p>当建立一棵新的树时，对应的 DOM 节点会被创建以及插入到 DOM 中，组件实例将执行 componentWillMount() 方法， </p><p>紧接着 componentDidMount() 方法； </p></li></ul><p>  比如下面的代码更改： </p><p>  React 会销毁<font color="blue">Top</font> 组件并且重新装载一个新的组件，而不会对<font color="blue">Top</font> 进行复用；</p><p>  <img src="https://yzaio.gitee.io/medias/images/13.png" alt="节点类型不同"></p><hr><p><strong>情况二：对比同一类型的元素</strong></p><ul><li>当比对两个相同类型的 React 元素时，React 会保留 DOM 节点，仅比对及更新有改变的属性。</li></ul><p>  比如下面的代码更改： </p><p>  通过比对这两个元素，React 知道只需要修改 DOM 元素上的 className 属性；</p><p>  <img src="https://yzaio.gitee.io/medias/images/2.png" alt=""></p><p>  比如下面的代码更改： </p><p>  当更新 style 属性时，React 仅更新有所更变的属性。</p><p>  通过比对这两个元素，React 知道只需要修改 DOM 元素上的 color 样式，无需修改 fontWeight。 </p><p>  <img src="https://yzaio.gitee.io/medias/images/3.png" alt=""></p><p>  如果是同类型的组件元素： </p><p>  组件会保持不变，React会更新该组件的props，并且调用componentWillReceiveProps() 和 componentWillUpdate() 方 </p><p>  法； </p><p>  下一步，调用 render() 方法，diff 算法将在之前的结果以及新的结果中进行递归；</p><hr><p><strong>情况三：对子节点进行递归</strong></p><p>在默认条件下，当递归 DOM 节点的子元素时，React 会同</p><p>时遍历两个子元素的列表；当产生差异时，生成一个</p><p>mutation。 </p><p>我们来看一下在最后插入一条数据的情况： </p><p><img src="https://yzaio.gitee.io/medias/images/5.png" alt=""></p><p>前面两个比较是完全相同的，所以不会产生mutation； </p><p>最后一个比较，产生一个mutation，将其插入到新的</p><p>DOM树中即可；</p><p>但是如果我们是在中间插入一条数据：</p><p><img src="https://yzaio.gitee.io/medias/images/14.png" alt="img"></p><p>这样react中新树的第一项与旧树的第一项进行比较，不对应，产生一个mutation，以此类推，</p><p>React会对每一个子元素产生一个mutation，则是三个mutation而不是保持 </p><li>first</li>和<li>second</li>的不变；<p></p><p>这种低效的比较方式会带来一定的性能问题；</p><p><font color="pink">所以为了解决这种低效的性能问题，可以加入keys的优化</font></p><p>我们在react中遍历列表时，在字元素不加key属性的话总是会提示一个警告，让我们加入一个key属性：</p><ul><li>方式一：在最后位置插入数据</li></ul><p>这种情况，有无key意义并不大</p><ul><li><p>方式二：在前面插入数据</p><ul><li>这种做法，在没有key的情况下，所有的li都需要进行修改； </li></ul></li></ul><p><img src="https://yzaio.gitee.io/medias/images/6.png" alt=""></p><p>当子元素(这里的li)拥有 key 时，React 使用 key 来匹配原有树上的子元素以及最新树上的子元素： </p><p>在下面这种场景下，key为111和222的元素仅仅进行位移，不需要进行任何的修改； </p><p>将key为333的元素插入到最前面的位置即可；</p><ul><li><em>key的注意事项</em>： </li></ul><p>key应该是唯一的；</p><p>key不要使用随机数（随机数在下一次render时，会重新生成一个数字）； </p><p>使用index作为key，对性能是没有优化的；</p><h2 id="2-vue中diff算法与react中diff算法区别"><a href="#2-vue中diff算法与react中diff算法区别" class="headerlink" title="2. vue中diff算法与react中diff算法区别"></a>2. vue中diff算法与react中diff算法区别</h2><ol><li>vue中diff算法在对新老虚拟daom进行对比时，是从节点的两侧向中间对比，而react是从节点左侧开始对比，就好比将新老虚拟dom放入两个栈中，一对多依次对比；</li><li>vue中在进行节点比较时节点的key值与元素类型相同，属性值不同，就会认为是不同节点，就会删除重建，而react中节点的key值与元素类型相同，属性值不同，react会认为是同类型节点，只是修改节点属性</li></ol><ul><li><p>两者的共同点：</p><p>都只进行同级比较，忽略了跨级操作；常见的现象就是对数组或者对象中的深层元素进行修改时，视图层监测不到其变化，故不会对dom进行更新，需调用一些特质方法来告诉视图层需要更新dom</p></li></ul><h2 id=""><a href="#" class="headerlink" title=""></a></h2><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端日常知识点</title>
      <link href="/2021/04/13/qian-duan-ri-chang-zhi-shi-dian/"/>
      <url>/2021/04/13/qian-duan-ri-chang-zhi-shi-dian/</url>
      
        <content type="html"><![CDATA[<h1 id="前端日常知识点"><a href="#前端日常知识点" class="headerlink" title="前端日常知识点"></a>前端日常知识点</h1><h2 id="1-CSS3的到来引入了一个非常有用的功能，就是calc-函数。有了它，在指定元素高度或宽度时，你可以基于计算进行设定，而不是简单的使用固定数值。这种功能在自适应网页布局设计中格外有用——针对不同尺寸的设备-电脑，平板，手机-，你需要动态的调整元素的大小，产生适合屏幕大小的不同布局"><a href="#1-CSS3的到来引入了一个非常有用的功能，就是calc-函数。有了它，在指定元素高度或宽度时，你可以基于计算进行设定，而不是简单的使用固定数值。这种功能在自适应网页布局设计中格外有用——针对不同尺寸的设备-电脑，平板，手机-，你需要动态的调整元素的大小，产生适合屏幕大小的不同布局" class="headerlink" title="1. CSS3的到来引入了一个非常有用的功能，就是calc()函数。有了它，在指定元素高度或宽度时，你可以基于计算进行设定，而不是简单的使用固定数值。这种功能在自适应网页布局设计中格外有用——针对不同尺寸的设备(电脑，平板，手机)，你需要动态的调整元素的大小，产生适合屏幕大小的不同布局"></a>1. CSS3的到来引入了一个非常有用的功能，就是<code>calc()</code>函数。有了它，在指定元素高度或宽度时，你可以基于计算进行设定，而不是简单的使用固定数值。这种功能在<a href="https://www.webhek.com/misc/responsive-web-design" target="_blank" rel="noopener">自适应网页布局设计</a>中格外有用——针对不同尺寸的设备(电脑，平板，手机)，你需要动态的调整元素的大小，产生适合屏幕大小的不同布局</h2><p>如以下写法</p><pre><code>height： calc(50% - 20px)//则高度为父盒子高度再减去20px</code></pre><p>这个计算器有个注意点 ：  就是calc()内部算法中间运算符需使用空格分隔否则不会生效</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组常用高阶语法</title>
      <link href="/2021/04/09/shu-zu-chang-yong-gao-jie-yu-fa/"/>
      <url>/2021/04/09/shu-zu-chang-yong-gao-jie-yu-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="数组常用高阶语法"><a href="#数组常用高阶语法" class="headerlink" title="数组常用高阶语法"></a>数组常用高阶语法</h1><h2 id="1-map方法"><a href="#1-map方法" class="headerlink" title="1. map方法"></a>1. map方法</h2><p>返回值为一个数组，可以对数组每一项进行处理并ruturn返回作为新数组的元素<br>可以传入三个参数</p><ul><li>第一个参数为当前元素的值</li><li>第二个参数为当前元素索引值</li><li>第三个参数为整个数组</li></ul><p>示例如下</p><pre><code>let arr = [1,2,3]let newArr = arr.map((item,index,arr) =&gt; {  return arr + 1})则arr就变为 [2,3,4]</code></pre><h2 id="2-filter方法"><a href="#2-filter方法" class="headerlink" title="2. filter方法"></a>2. filter方法</h2><p>返回值为一个数组，可以对数组每一项进行检查判断，把检查完为true的元素ruturn返回作为新数组的元素<br>可以传入三个参数（与map一致）</p><ul><li>第一个参数为当前元素的值</li><li>第二个参数为当前元素索引值</li><li>第三个参数为整个数组</li></ul><pre><code>let arr = [1,2,3]let newArr = arr.map((item,index,arr) =&gt; {  return arr &gt; 1})则arr就变为 [2,3]</code></pre><h2 id="3-reduce方法"><a href="#3-reduce方法" class="headerlink" title="3. reduce方法"></a>3. reduce方法</h2><p>返回值为循环结束后return出来的累加值，可以作为一个累加器<br>可以传入两个参数</p><ul><li>第一个参数为回调函数<ul><li>回调函数的参数<ul><li>第一个参数： 上一次回调函数的结果（第一次没有上一次函数的回调函数的结果, 使用初始化值即是reduce方法的第二个参数）</li><li>第二个参数为当前元素的值</li><li>第三个参数为当前元素索引值</li><li>第四个参数为整个数组</li></ul></li></ul></li><li>第二个参数为初始值</li></ul><pre><code>let arr = [1,2,3]let total = arr.reduce((preValue,item,index,arr) =&gt; {  return preValue + item},10)则total最终结果为10 + 1 + 2 + 3 = 16</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react学习</title>
      <link href="/2021/04/07/react-xue-xi/"/>
      <url>/2021/04/07/react-xue-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="react学习"><a href="#react学习" class="headerlink" title="react学习"></a>react学习</h1><h2 id="1-jsx本质"><a href="#1-jsx本质" class="headerlink" title="1. jsx本质"></a>1. jsx本质</h2><ul><li>jsx -&gt; createElement函数 -&gt; ReactElement(对象树) -&gt; ReactDOM.    render -&gt; 真实DOM<br> jsx -&gt; createElement函数 -&gt; ReactElement(对象树) -&gt; ReactDOM.rensder -&gt; 原生的控件(UIButton/Button)</li></ul><h2 id="2-使用虚拟dom的好处"><a href="#2-使用虚拟dom的好处" class="headerlink" title="2.使用虚拟dom的好处"></a>2.使用虚拟dom的好处</h2><ul><li>jq和原生js等是直接操作真是Dom进行修改页面，而react是用一个jascript对象的虚拟Dom先来描述ui，再使用ReactDom.render来将虚拟dom转化成真实dom形成页面，这样可以避免了频繁操作真实dom树，提高性能，因为本来document.creatElement这个方法创建出来的Dom就是很复杂的东西，而ReactElemnt对象要比它简单很多。</li></ul><h2 id="3-React中设计原则-state中的数据的不可变性"><a href="#3-React中设计原则-state中的数据的不可变性" class="headerlink" title="3. React中设计原则: state中的数据的不可变性;"></a>3. React中设计原则: state中的数据的不可变性;</h2><ul><li><p>即是在修改state中的数据时，不要去修改到原来内部的数据项</p><p><font color="lightGreen">原因是当我们组件是继承自pureComponent或者自己书写的对比前后state是否改变来决定组件是否渲染的高阶组件时，我们如果在setState修改state数据时，先改变了原来的state值得话，有时会造成组件不会重新渲染render的风险，所以我们在进行setState修改数据时，应该遵守state中的数据的不可变性</font></p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue项目知识点</title>
      <link href="/2021/03/31/vue-xiang-mu-zhi-shi-dian/"/>
      <url>/2021/03/31/vue-xiang-mu-zhi-shi-dian/</url>
      
        <content type="html"><![CDATA[<h1 id="vue项目知识点"><a href="#vue项目知识点" class="headerlink" title="vue项目知识点"></a>vue项目知识点</h1><h2 id="1-页面前进后退不刷新问题"><a href="#1-页面前进后退不刷新问题" class="headerlink" title="1.  页面前进后退不刷新问题"></a>1.  页面前进后退不刷新问题</h2><ul><li><p>页面使用hash模式时页面使用网页的前进后退会出现地址栏地址变化但是不刷新的情况，在全局添加Bom事件操作如下来解决问题</p><p>  window.addEventListener(‘hashchange’, () =&gt; {</p><p>  let currentPath = window.location.hash.slice(1)</p><p>  if (this.$route.path !== currentPath) {</p><p>  this.$router.push(currentPath)</p><p>  }</p><p>  }, false)</p></li></ul><hr><h2 id="2-禁止缩放方法"><a href="#2-禁止缩放方法" class="headerlink" title="2. 禁止缩放方法"></a>2. 禁止缩放方法</h2><ul><li><p>可以在index.html页面加上以下代码禁止页面缩放</p><p><code>&lt;meta name="viewport" content="width=device-width,initial-scale=1.0,,minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"&gt;</code></p></li></ul><hr><h2 id="3-watch监听数组不更新问题"><a href="#3-watch监听数组不更新问题" class="headerlink" title="3. watch监听数组不更新问题"></a>3. watch监听数组不更新问题</h2><ul><li><p>watch对于数组或者对象在某些特定情况下是无法监听到的。这种情况其实和双向绑定的原理有关。Vue双向绑定原理是利用js中的Object.defineproperty重定义对象的GET和SET方法，而同时这种方法存在着缺陷，就是只能监听到对象内已有的值，如果需要改变数组中某个值被监听到的话，直接通过数组的index然后去改变的话无法在watch里面监听到，可以通过临时变量中转的方法：</p><p>  let tempArr = […this.targetArr]</p><p>  tempArr[0] = {data: ‘test’}</p><p>  this.targetArr = tempArr</p></li></ul><hr><h2 id="4-上传文件接口参数问题"><a href="#4-上传文件接口参数问题" class="headerlink" title="4. 上传文件接口参数问题"></a>4. 上传文件接口参数问题</h2><ul><li>批量导入的文件上传不能使用平常的数据类型传参，在axios请求中还需要定义header头部的Content-Type来更换此请求为文件上传类型，传参对象需要new一个FormData，把需要传参得数据，通过append方法加进去</li></ul><p><code>'Content-Type': 'multipart/form-data; boundary = ' + new Date().getTime()</code> </p><hr><h2 id="5-移动端解决300ms延迟"><a href="#5-移动端解决300ms延迟" class="headerlink" title="5.移动端解决300ms延迟"></a>5.移动端解决300ms延迟</h2><ul><li><p>移动端为了识别用户单击双击会在用户第一次点击的时候产生300ms延迟，为了解决这个延迟，可以使用第三方包fastclick，通过npm安装后，在项目的main.js中引入，并使用它其中的attach方法fastclick.attach(document.body)来解决延迟。</p><p>使用fastclick包</p><pre><code>1. npm install fastclick --save2. 在mian.js中使用</code></pre><p>  import FastClick from ‘fastclick’<br>  //使用包其中的attach方法<br>  FastClick.attach(document.body)</p></li></ul><hr><h2 id=""><a href="#" class="headerlink" title=""></a></h2><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ie11踩坑点</title>
      <link href="/2021/03/31/ie11-cai-keng-dian/"/>
      <url>/2021/03/31/ie11-cai-keng-dian/</url>
      
        <content type="html"><![CDATA[<h1 id="ie11踩坑点"><a href="#ie11踩坑点" class="headerlink" title="ie11踩坑点"></a>ie11踩坑点</h1><h5 id="1-Ie11对于new-Date（）里面的值如果是用-分隔开的话会出现nan，需要使用正则表达式去替换成-来解决问题"><a href="#1-Ie11对于new-Date（）里面的值如果是用-分隔开的话会出现nan，需要使用正则表达式去替换成-来解决问题" class="headerlink" title="1. Ie11对于new Date（）里面的值如果是用/分隔开的话会出现nan，需要使用正则表达式去替换成-来解决问题"></a>1. Ie11对于new Date（）里面的值如果是用/分隔开的话会出现nan，需要使用正则表达式去替换成-来解决问题</h5><hr><h5 id="2-ie11上不支持新的css3变量写法，使用变量写法处会出现不生效情况。"><a href="#2-ie11上不支持新的css3变量写法，使用变量写法处会出现不生效情况。" class="headerlink" title="2. ie11上不支持新的css3变量写法，使用变量写法处会出现不生效情况。"></a>2. ie11上不支持新的css3变量写法，使用变量写法处会出现不生效情况。</h5><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack配置代理的注意点</title>
      <link href="/2021/03/31/webpack-pei-zhi-dai-li-de-zhu-yi-dian/"/>
      <url>/2021/03/31/webpack-pei-zhi-dai-li-de-zhu-yi-dian/</url>
      
        <content type="html"><![CDATA[<h1 id="使用webpack代理服务的注意点"><a href="#使用webpack代理服务的注意点" class="headerlink" title="使用webpack代理服务的注意点"></a>使用webpack代理服务的注意点</h1><p> 使用webpack配置代理访问解决跨域问题时，检索地址名如果与路由活跃 地址有相同时，会导致该路由页面刷新不存在，并且无法直接用该路由地址 访问页面，通过修改wenbpack配置内部的检索地址名或者改变路由活跃路 径解决问题。</p><h2 id="示例如下"><a href="#示例如下" class="headerlink" title="示例如下"></a>示例如下</h2><p><img src="https://yzaio.gitee.io/medias/images/12.png" alt=""><br><strong><em>代理服务使用了test作为配置路径</em></strong><br>如果在路由内部使用了/test作为前端路由路径的话，使用push跳转不会出现错误，但是当刷新页面或者使用/test直接作为地址访问页面无法找到。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>element踩坑注意</title>
      <link href="/2021/03/31/element-cai-keng-zhu-yi/"/>
      <url>/2021/03/31/element-cai-keng-zhu-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="element踩坑点"><a href="#element踩坑点" class="headerlink" title="element踩坑点"></a>element踩坑点</h1><ol><li>使用element输出框并且增加标签属性required的时候，出现输入框输入字符后再删到无字符情况下会校验出现英文状态，需要去掉此属性来解决问题。</li></ol><hr><ol start="2"><li>使用element组件校验规则要校验多选框的时候，不能在created周期内定义空数组，反正会出现校验bug，需要先给另外一个变量定义数组后赋值到该项上就可以</li></ol><hr><ol start="3"><li>Element组件库的cascader组件在ie11下，如果数据项字段太长会出现显示不全的状况，通过加入以下代码改变下拉框的宽度来解决问题<br><code>@media all and (-ms-high-contrast: none), (-ms-high-contrast: active) { .el-cascader__dropdown .el-cascader-menu { width: 320px !important; } }</code></li></ol><ul><li>其中320px为可改变值  根据自身项目数据的长度去进行调整</li></ul><hr><ol start="4"><li><p>项目使用elementui组件库的时候，因为设计可能采用的主题色不同，需要修改大部分element组件的默认色的话，可以使用scss来进行全局统一修改，通过安装主题修改器来生成并修改scss文件，修改element默认主题色，代码如下(<a href="https://element.eleme.cn/#/zh-CN/component/custom-theme" target="_blank" rel="noopener">更具体可参考element官网更换主题步骤</a>)：</p><ul><li>cd element-demo</li><li>npm i element-theme -g</li><li>npm i element-theme-chalk -D</li><li>et -i</li><li>修改scss中的颜色值</li><li>et   </li></ul></li></ol><hr><ol start="5"><li>element的select组件在ie11上打开还有关闭会闪现滚动条，通过在该vue文件最外层div定义样式超出省略overflow-x: hidden;overflow-y:visible!important;解决问题。</li></ol><hr><ol start="6"><li>标签超过省略展示更多的按钮或者文字如果要放在文字同一行，不能单纯使用-webkit-line-clamp:2的方法，需要操作相应标签dom节点获取标签的自带的原生方法getClientRects（），通过数组长度来判定行数，再切割我们需要行数的字符数，把展示更多的按钮或者文字塞到同一行</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>臭猪头，对不起，好好的</title>
      <link href="/2020/06/21/chou-zhu-tou-dui-bu-qi-hao-hao-de/"/>
      <url>/2020/06/21/chou-zhu-tou-dui-bu-qi-hao-hao-de/</url>
      
        <content type="html"><![CDATA[<h2 id="Name"><a href="#Name" class="headerlink" title="Name"></a>Name</h2><ul><li>徐文莉</li></ul><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><ul><li>猪</li></ul><h2 id="picture"><a href="#picture" class="headerlink" title="picture"></a>picture</h2><p><img src="https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2256160164,2873615387&amp;fm=26&amp;gp=0.jpg" alt="开心一点"></p><h2 id="对不起，让你受了这么多伤"><a href="#对不起，让你受了这么多伤" class="headerlink" title="对不起，让你受了这么多伤"></a>对不起，让你受了这么多伤</h2><p><img src="https://yzaio.gitee.io/medias/images/111.mp4" alt=""><br><img src="https://yzaio.gitee.io/medias/images/2.jpg" alt=""><br><img src="https://yzaio.gitee.io/medias/images/111.mkv" alt=""></p><video id="video" controls="" preload="none" poster="https://yzaio.gitee.io/medias/images/2.jpg">     <source id="mp4" src="https://yzaio.gitee.io/medias/images/111.mkv" type="video/mp4"></video>-555<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> love </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基本数据类型与复杂数据类型</title>
      <link href="/2020/06/12/ji-ben-shu-ju-lei-xing-yu-fu-za-shu-ju-lei-xing/"/>
      <url>/2020/06/12/ji-ben-shu-ju-lei-xing-yu-fu-za-shu-ju-lei-xing/</url>
      
        <content type="html"><![CDATA[<p>title: 基本数据类型与复杂数据类型<br>date: 2020-06-21 20:21:55<br>tags: Web</p><h2 id="一-基本数据类型"><a href="#一-基本数据类型" class="headerlink" title="一. 基本数据类型"></a>一. 基本数据类型</h2><ol><li>基本数据类型有<br>string number boolean nul undefined<ul><li>他们赋值的时候是保存在栈里面的</li></ul></li></ol><ul><li><p>当出现相互赋值的以下情况<br>var a = 1<br>var b = a<br><strong>这个时候只是把a的值赋值给b，两者变量存放的地址并不相同，所以两者改变自己的值另外一方不受影响</strong></p><p><img src="https://yzaio.gitee.io/medias/images/15.png" alt="基本数据类型"></p><h2 id="二-复杂数据类型"><a href="#二-复杂数据类型" class="headerlink" title="二. 复杂数据类型"></a>二. 复杂数据类型</h2><ol start="2"><li>复杂数据类型<br>object array function<ul><li>他们赋值声明的时候，是保存在堆里面的，而且和基本数据类型不同的是我们给基本数据类型赋值的时候就是直接把值赋过去，但是我们给复杂数据类型赋值的时候是在堆中为它开辟一个内存地址用于存放数据，而我们只是把这个数据的存放的内存地址赋值给这个复杂数据类型</li><li>所以当出现以下情况，以对象为例子<br>var obj = {name: ‘kobe’}<br>var newObj = obj<br>newObj.name = ‘wade’<br>console.log(obj) //{name: ‘wade’}<br>//这个时候我们是把obj的内存地址给到了newObj，所以两个变量都同时指向这个区域，当任何一方发生改变的时候，另外一方也会发生改变<br><img src="https://yzaio.gitee.io/medias/images/16.png" alt="复杂数据类型"></li></ul></li></ol></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
